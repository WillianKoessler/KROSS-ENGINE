#include <Kross_pch.h>
#include "GLErrors.h"

std::vector<glError> glError::cache;
unsigned int glError::count = 0;
bool glError::active = false;

void glDebugMessage(
	GLenum source,
	GLenum type,
	GLuint id,
	GLenum severity,
	GLsizei length,
	const GLchar* message,
	const void* userParam)
{
	char* ctype = "Unknown", * cseverity = "Unknown", * csource = "Unknown", * cid = "Unknown";
	switch (source)
	{
	case GL_DEBUG_SOURCE_API: { csource = "API"; break; }							//Calls to the OpenGL API
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM: { csource = "WINDOW_SYSTEM"; break; }		//Calls to a window - system API
	case GL_DEBUG_SOURCE_SHADER_COMPILER: { csource = "SHADER_COMPILER"; break; }	//A compiler for a shading language
	case GL_DEBUG_SOURCE_THIRD_PARTY: { csource = "THIRD_PARTY"; break; }			//An application associated with OpenGL
	case GL_DEBUG_SOURCE_APPLICATION: { csource = "APPLICATION"; break; }			//Generated by the user of this application
	case GL_DEBUG_SOURCE_OTHER: { csource = "OTHER"; break; }						//Some source that isn't one of these
	}

	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR: { ctype = "ERROR"; break; }								//An error, typically from the API
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: { ctype = "DEPRECATED_BEHAVIOR"; break; }	//Some behavior marked deprecated has been used
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: { ctype = "UNDEFINED_BEHAVIOR"; break; }		//Something has invoked undefined behavior
	case GL_DEBUG_TYPE_PORTABILITY: { ctype = "PORTABILITY"; break; }					//Some functionality the user relies upon is not portable
	case GL_DEBUG_TYPE_PERFORMANCE: { ctype = "PERFORMANCE"; break; }					//Code has triggered possible performance issues
	case GL_DEBUG_TYPE_MARKER: { ctype = "MARKER"; break; }								//Command stream annotation
	case GL_DEBUG_TYPE_PUSH_GROUP: { ctype = "PUSH_GROUP"; break; }						//Group pushing
	case GL_DEBUG_TYPE_POP_GROUP: { ctype = "POP_GROUP"; break; }						//Group popping
	case GL_DEBUG_TYPE_OTHER: { ctype = "OTHER"; break; }								//Some type that isn't one of these
	}
	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH: { cseverity = "HIGH"; break; }			//All OpenGL Errors, shader compilation/linking errors, or highly-dangerous undefined behavior
	case GL_DEBUG_SEVERITY_MEDIUM: { cseverity = "MEDIUM"; break; }		//Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality
	case GL_DEBUG_SEVERITY_LOW: { cseverity = "LOW"; break; }			//Redundant state change performance warning, or unimportant undefined behavior
	}
	switch (id)
	{
	case GL_INVALID_ENUM:					{ cid = "INVALID_ENUM"; break; }
	case GL_INVALID_VALUE:					{ cid = "GL_INVALID_VALUE"; break; }
	case GL_INVALID_OPERATION:				{ cid = "GL_INVALID_OPERATION"; break; }
	case GL_INVALID_FRAMEBUFFER_OPERATION:	{ cid = "GL_INVALID_FRAMEBUFFER_OPERATION"; break; }
	case GL_OUT_OF_MEMORY:					{ cid = "GL_OUT_OF_MEMORY"; break; }
	case GL_STACK_UNDERFLOW:				{ cid = "GL_STACK_UNDERFLOW"; break; }
	}

	KROSS_CORE_ERROR_("	**GL CALLBACK**");
	KROSS_CORE_ERROR_("TYPE: {0}", ctype);
	KROSS_CORE_ERROR_("SEVERITY: {0}", cseverity);
	KROSS_CORE_ERROR_("SOURCE: {0}", csource);
	KROSS_CORE_ERROR_("ID: {0}", cid);
	KROSS_CORE_ERROR_("MESSAGE: {0}", message);
}

glError::glError(const std::string& func_, const std::string& file_, int line_)
	: func(func_),
	file(file_),
	line(line_),
	codes(),
	id(++count)
{
	if (active)
		code = glGetError();
	else
	{
		KROSS_CORE_ERROR_("Trying to use glError without active instance of handler");
	}
}
glError::glError(const std::string& func_, const std::string& file_, int line_, unsigned int code_)
	: func(func_),
	file(file_),
	line(line_),
	codes(),
	code(code_),
	id(++count)
{}
void glError::Begin()
{
	if (cache.empty() && !active && count == 0)
		active = true;
	else
	{
		KROSS_CORE_ERROR_("Trying to initilize OpenGL Error Handler with an already initialized instance.");
	}
}
void glError::flushCache()
{
	if (active)
	{
		cache.clear();
		count = 0;
		active = false;
	}
	else
	{
		KROSS_CORE_ERROR_("Trying to flush OpenGL Error Handler without an valid instance.");
	}
}
bool glError::hasError()
{
	return code != GL_NO_ERROR;
}
bool glError::handle()
{
	if (active)
	{
		while (hasError() && !handled(*this))
		{
			codes.push_back(code);
			display(*this);
		}
	}
	else return false;
	return true;
}
void glError::display(const glError& error)
{
	KROSS_CORE_ERROR_("FILE: {0}", error.file);
	KROSS_CORE_ERROR_("LINE: {0}", error.line);
	KROSS_CORE_ERROR_("FUNCTION: {0}", error.func);
}
bool glError::handled(const glError& error)
{
	auto i = std::lower_bound(cache.begin(), cache.end(), error,
		[](const glError& other, const glError& k) { return other.id < k.id; });
	if (i < cache.end() && !(i->id < error.id)) return true;
	else cache.emplace(i, error);
	return false;
}
glError::operator unsigned int()
{
	return code;
}
void glError::glGetErrors(const char* function, const char* file, int line)
{
	glError error(function, file, line);
	error.handle();
}
